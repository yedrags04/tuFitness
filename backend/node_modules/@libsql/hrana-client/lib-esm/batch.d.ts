import type * as proto from "./proto.js";
import type { RowsResult, RowResult, ValueResult, StmtResult } from "./result.js";
import type { InStmt } from "./stmt.js";
import { Stream } from "./stream.js";
/** A builder for creating a batch and executing it on the server. */
export declare class Batch {
    #private;
    /** @private */
    _stream: Stream;
    /** @private */
    _steps: Array<proto.BatchStep>;
    /** @private */
    _resultCallbacks: Array<(_: proto.BatchResult) => void>;
    /** @private */
    constructor(stream: Stream);
    /** Return a builder for adding a step to the batch. */
    step(): BatchStep;
    /** Execute the batch. */
    execute(): Promise<void>;
}
/** A builder for adding a step to the batch. */
export declare class BatchStep {
    #private;
    /** @private */
    _index: number | undefined;
    /** @private */
    constructor(batch: Batch);
    /** Add the condition that needs to be satisfied to execute the statement. If you use this method multiple
    * times, we join them with a logical AND. */
    condition(cond: BatchCond): this;
    /** Add a statement that returns rows. */
    query(stmt: InStmt): Promise<RowsResult | undefined>;
    /** Add a statement that returns at most a single row. */
    queryRow(stmt: InStmt): Promise<RowResult | undefined>;
    /** Add a statement returns at most a single value. */
    queryValue(stmt: InStmt): Promise<ValueResult | undefined>;
    /** Add a statement without returning rows. */
    run(stmt: InStmt): Promise<StmtResult | undefined>;
}
export declare class BatchCond {
    /** @private */
    _proto: proto.BatchCond;
    /** @private */
    constructor(proto: proto.BatchCond);
    static ok(step: BatchStep): BatchCond;
    static error(step: BatchStep): BatchCond;
    static not(cond: BatchCond): BatchCond;
    static and(conds: Array<BatchCond>): BatchCond;
    static or(conds: Array<BatchCond>): BatchCond;
}
