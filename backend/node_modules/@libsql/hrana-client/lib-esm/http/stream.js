import { Request, Headers } from "@libsql/isomorphic-fetch";
import { ClientError, HttpServerError, ProtoError, ClosedError } from "../errors.js";
import { IdAlloc } from "../id_alloc.js";
import { queueMicrotask } from "../ponyfill.js";
import { errorFromProto } from "../result.js";
import { Sql } from "../sql.js";
import { Stream } from "../stream.js";
export class HttpStream extends Stream {
    #client;
    #baseUrl;
    #jwt;
    #fetch;
    #closed;
    #baton;
    #pipeline;
    #pipelineInProgress;
    #sqlIdAlloc;
    /** @private */
    constructor(client, baseUrl, jwt, customFetch) {
        super(client.intMode);
        this.#client = client;
        this.#baseUrl = baseUrl.toString();
        this.#jwt = jwt;
        this.#fetch = customFetch;
        this.#closed = undefined;
        this.#baton = null;
        this.#pipeline = [];
        this.#pipelineInProgress = false;
        this.#sqlIdAlloc = new IdAlloc();
    }
    /** @private*/
    _sqlOwner() {
        return this;
    }
    /** Cache a SQL text on the server. */
    storeSql(sql) {
        const sqlId = this.#sqlIdAlloc.alloc();
        const sqlState = {
            sqlId,
            closed: undefined,
        };
        this.#sendStreamRequest({
            "type": "store_sql",
            "sql_id": sqlId,
            "sql": sql,
        }).then(() => undefined, (error) => this.#setClosed(error));
        return new Sql(this, sqlState);
    }
    /** @private */
    _closeSql(sqlState, error) {
        if (sqlState.closed !== undefined || this.#closed !== undefined) {
            return;
        }
        sqlState.closed = error;
        this.#sendStreamRequest({
            "type": "close_sql",
            "sql_id": sqlState.sqlId,
        }).then(() => this.#sqlIdAlloc.free(sqlState.sqlId), (error) => this.#setClosed(error));
    }
    /** @private */
    _execute(stmt) {
        return this.#sendStreamRequest({
            "type": "execute",
            "stmt": stmt,
        }).then((response) => {
            return response["result"];
        });
    }
    /** @private */
    _batch(batch) {
        return this.#sendStreamRequest({
            "type": "batch",
            "batch": batch,
        }).then((response) => {
            return response["result"];
        });
    }
    /** @private */
    _describe(protoSql) {
        return this.#sendStreamRequest({
            "type": "describe",
            "sql": protoSql.sql,
            "sql_id": protoSql.sqlId,
        }).then((response) => {
            return response["result"];
        });
    }
    /** @private */
    _sequence(protoSql) {
        return this.#sendStreamRequest({
            "type": "sequence",
            "sql": protoSql.sql,
            "sql_id": protoSql.sqlId,
        }).then((_response) => {
            return undefined;
        });
    }
    /** Close the stream. */
    close() {
        this.#setClosed(new ClientError("Stream was manually closed"));
    }
    /** @private */
    _closeFromClient() {
        this.#setClosed(new ClosedError("Client was closed", undefined));
    }
    /** True if the stream is closed. */
    get closed() {
        return this.#closed !== undefined;
    }
    #setClosed(error) {
        if (this.#closed !== undefined) {
            return;
        }
        this.#closed = error;
        this.#client._streamClosed(this);
        if (this.#baton !== null || this.#pipeline.length !== 0 || this.#pipelineInProgress) {
            this.#pipeline.push({
                request: { "type": "close" },
                responseCallback() { },
                errorCallback() { },
            });
            this.#flushPipeline();
        }
    }
    #sendStreamRequest(request) {
        if (this.#closed !== undefined) {
            return Promise.reject(new ClosedError("Stream is closed", this.#closed));
        }
        return new Promise((responseCallback, errorCallback) => {
            this.#pipeline.push({ request, responseCallback, errorCallback });
            queueMicrotask(() => this.#flushPipeline());
        });
    }
    #flushPipeline() {
        if (this.#pipeline.length === 0 || this.#pipelineInProgress) {
            return;
        }
        const pipeline = Array.from(this.#pipeline);
        let promise;
        try {
            const request = this.#createPipelineRequest(pipeline);
            const fetch = this.#fetch;
            promise = fetch(request);
        }
        catch (error) {
            promise = Promise.reject(error);
        }
        this.#pipelineInProgress = true;
        this.#pipeline.length = 0;
        promise.then((resp) => {
            if (!resp.ok) {
                return errorFromResponse(resp).then((error) => {
                    throw error;
                });
            }
            return resp.json();
        }).then((respJson) => {
            const respBody = respJson;
            this.#baton = respBody["baton"] ?? null;
            this.#baseUrl = respBody["base_url"] ?? this.#baseUrl;
            handlePipelineResponse(pipeline, respBody);
        }).catch((error) => {
            this.#setClosed(error);
            for (const entry of pipeline) {
                entry.errorCallback(error);
            }
        }).finally(() => {
            this.#pipelineInProgress = false;
            this.#flushPipeline();
        });
    }
    #createPipelineRequest(pipeline) {
        const url = new URL("v2/pipeline", this.#baseUrl);
        const requestBody = {
            "baton": this.#baton,
            "requests": pipeline.map((entry) => entry.request),
        };
        const headers = new Headers();
        if (this.#jwt !== null) {
            headers.set("authorization", `Bearer ${this.#jwt}`);
        }
        return new Request(url.toString(), {
            method: "POST",
            headers,
            body: JSON.stringify(requestBody),
        });
    }
}
function handlePipelineResponse(pipeline, respBody) {
    if (respBody["results"].length !== pipeline.length) {
        throw new ProtoError("Server returned unexpected number of pipeline results");
    }
    for (let i = 0; i < pipeline.length; ++i) {
        const result = respBody["results"][i];
        const entry = pipeline[i];
        if (result["type"] === "ok") {
            if (result["response"]["type"] !== entry.request["type"]) {
                throw new ProtoError("Received unexpected type of response");
            }
            entry.responseCallback(result["response"]);
        }
        else if (result["type"] === "error") {
            entry.errorCallback(errorFromProto(result["error"]));
        }
        else {
            throw new ProtoError("Received unexpected type of result");
        }
    }
}
async function errorFromResponse(resp) {
    const respType = resp.headers.get("content-type") ?? "text/plain";
    if (respType === "application/json") {
        const respBody = await resp.json();
        if ("message" in respBody) {
            return errorFromProto(respBody);
        }
    }
    let message = `Server returned HTTP status ${resp.status}`;
    if (respType === "text/plain") {
        const respBody = (await resp.text()).trim();
        if (respBody !== "") {
            message += `: ${respBody}`;
        }
    }
    if (resp.status === 404) {
        message += ". It seems that the libsql server is outdated, please try updating the database.";
    }
    return new HttpServerError(message, resp.status);
}
