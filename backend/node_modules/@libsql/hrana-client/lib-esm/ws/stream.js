import { ClientError } from "../errors.js";
import { Stream } from "../stream.js";
export class WsStream extends Stream {
    #client;
    #state;
    /** @private */
    constructor(client, state) {
        super(client.intMode);
        this.#client = client;
        this.#state = state;
    }
    /** @private */
    _sqlOwner() {
        return this.#client;
    }
    /** @private */
    _execute(stmt) {
        return this.#sendStreamRequest({
            "type": "execute",
            "stream_id": this.#state.streamId,
            "stmt": stmt,
        }).then((response) => {
            return response["result"];
        });
    }
    /** @private */
    _batch(batch) {
        return this.#sendStreamRequest({
            "type": "batch",
            "stream_id": this.#state.streamId,
            "batch": batch,
        }).then((response) => {
            return response["result"];
        });
    }
    /** @private */
    _describe(protoSql) {
        this.#client._ensureVersion(2, "describe()");
        return this.#sendStreamRequest({
            "type": "describe",
            "stream_id": this.#state.streamId,
            "sql": protoSql.sql,
            "sql_id": protoSql.sqlId,
        }).then((response) => {
            return response["result"];
        });
    }
    /** @private */
    _sequence(protoSql) {
        this.#client._ensureVersion(2, "sequence()");
        return this.#sendStreamRequest({
            "type": "sequence",
            "stream_id": this.#state.streamId,
            "sql": protoSql.sql,
            "sql_id": protoSql.sqlId,
        }).then((_response) => {
            return undefined;
        });
    }
    #sendStreamRequest(request) {
        return new Promise((responseCallback, errorCallback) => {
            this.#client._sendStreamRequest(this.#state, request, { responseCallback, errorCallback });
        });
    }
    /** Close the stream. */
    close() {
        this.#client._closeStream(this.#state, new ClientError("Stream was manually closed"));
    }
    /** True if the stream is closed. */
    get closed() {
        return this.#state.closed !== undefined;
    }
}
